<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BSMPT: BSMPT::BounceActionInt Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">BSMPT<span id="projectnumber">&#160;3.1.3</span>
   </div>
   <div id="projectbrief">BSMPT - Beyond the Standard Model Phase Transitions : A C++ package for the computation of the EWPT in BSM models</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classBSMPT_1_1BounceActionInt.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classBSMPT_1_1BounceActionInt-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">BSMPT::BounceActionInt Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad0e65e97ac71874b3d21db50d8cbd1ff" id="r_ad0e65e97ac71874b3d21db50d8cbd1ff"><td class="memItemLeft" align="right" valign="top"><a id="ad0e65e97ac71874b3d21db50d8cbd1ff" name="ad0e65e97ac71874b3d21db50d8cbd1ff"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#ad0e65e97ac71874b3d21db50d8cbd1ff">ActionStatus</a> { <br />
&#160;&#160;<b>Success</b>
, <b>NotCalculated</b>
, <b>Integration1DFailed</b>
, <b>PathDeformationNotConverged</b>
, <br />
&#160;&#160;<b>PathDeformationCrashed</b>
, <b>FalseVacuumNotMinimum</b>
, <b>BackwardsPropagationFailed</b>
, <b>NeverUndershootOvershoot</b>
, <br />
&#160;&#160;<b>UndershootOvershootNegativeGrad</b>
, <b>NotEnoughPointsForSpline</b>
<br />
 }</td></tr>
<tr class="memdesc:ad0e65e97ac71874b3d21db50d8cbd1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible status of the Action calculation. <br /></td></tr>
<tr class="separator:ad0e65e97ac71874b3d21db50d8cbd1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03efb7c6b290961c4892471f55e164af" id="r_a03efb7c6b290961c4892471f55e164af"><td class="memItemLeft" align="right" valign="top"><a id="a03efb7c6b290961c4892471f55e164af" name="a03efb7c6b290961c4892471f55e164af"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a03efb7c6b290961c4892471f55e164af">UndershootOvershootStatus</a> { <b>Converged</b>
, <b>Undershoot</b>
, <b>Overshoot</b>
 }</td></tr>
<tr class="memdesc:a03efb7c6b290961c4892471f55e164af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible results of the undershoot/overshoot algorithm. <br /></td></tr>
<tr class="separator:a03efb7c6b290961c4892471f55e164af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3feb2cc85873eb12de9c961c56314b" id="r_a2f3feb2cc85873eb12de9c961c56314b"><td class="memItemLeft" align="right" valign="top"><a id="a2f3feb2cc85873eb12de9c961c56314b" name="a2f3feb2cc85873eb12de9c961c56314b"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a2f3feb2cc85873eb12de9c961c56314b">Integration1DStatus</a> { <b>Converged</b>
, <b>NotConverged</b>
 }</td></tr>
<tr class="memdesc:a2f3feb2cc85873eb12de9c961c56314b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible status of the 1D bounce solver. <br /></td></tr>
<tr class="separator:a2f3feb2cc85873eb12de9c961c56314b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2647c816f414debde47db27d5b52326" id="r_ac2647c816f414debde47db27d5b52326"><td class="memItemLeft" align="right" valign="top"><a id="ac2647c816f414debde47db27d5b52326" name="ac2647c816f414debde47db27d5b52326"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#ac2647c816f414debde47db27d5b52326">PathDeformationStatus</a> { <b>Converged</b>
, <b>NotConverged</b>
 }</td></tr>
<tr class="memdesc:ac2647c816f414debde47db27d5b52326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible status of the path deformation algorithm. <br /></td></tr>
<tr class="separator:ac2647c816f414debde47db27d5b52326"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9fe7ef616a673ec2603f1cbea847224e" id="r_a9fe7ef616a673ec2603f1cbea847224e"><td class="memItemLeft" align="right" valign="top"><a id="a9fe7ef616a673ec2603f1cbea847224e" name="a9fe7ef616a673ec2603f1cbea847224e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BounceActionInt</b> ()</td></tr>
<tr class="memdesc:a9fe7ef616a673ec2603f1cbea847224e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor (unit tests) <br /></td></tr>
<tr class="separator:a9fe7ef616a673ec2603f1cbea847224e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd14beac6a70fe7152ec3ecd80592b6" id="r_addd14beac6a70fe7152ec3ecd80592b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#addd14beac6a70fe7152ec3ecd80592b6">BounceActionInt</a> (std::vector&lt; std::vector&lt; double &gt; &gt; InitPath_In, std::vector&lt; double &gt; TrueVacuum_In, std::vector&lt; double &gt; FalseVacuum_In, std::function&lt; double(std::vector&lt; double &gt;)&gt; &amp;V_In, std::function&lt; std::vector&lt; double &gt;(std::vector&lt; double &gt;)&gt; &amp;dV_In, double T_In, int MaxPathIntegrations_in)</td></tr>
<tr class="memdesc:addd14beac6a70fe7152ec3ecd80592b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Bounce Action Int object.  <br /></td></tr>
<tr class="separator:addd14beac6a70fe7152ec3ecd80592b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4511691cd660bf2efa86ba7869bb4d14" id="r_a4511691cd660bf2efa86ba7869bb4d14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a4511691cd660bf2efa86ba7869bb4d14">BounceActionInt</a> (std::vector&lt; std::vector&lt; double &gt; &gt; InitPath_In, std::vector&lt; double &gt; TrueVacuum_In, std::vector&lt; double &gt; FalseVacuum_In, std::function&lt; double(std::vector&lt; double &gt;)&gt; &amp;V_In, double T_In, int MaxPathIntegrations_in)</td></tr>
<tr class="memdesc:a4511691cd660bf2efa86ba7869bb4d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Bounce Action Int object.  <br /></td></tr>
<tr class="separator:a4511691cd660bf2efa86ba7869bb4d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d6d6bc80d22df57248a09f8a493f94" id="r_a73d6d6bc80d22df57248a09f8a493f94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a73d6d6bc80d22df57248a09f8a493f94">SetPath</a> (std::vector&lt; std::vector&lt; double &gt; &gt; InitPath_In)</td></tr>
<tr class="memdesc:a73d6d6bc80d22df57248a09f8a493f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used set the path of the class.  <br /></td></tr>
<tr class="separator:a73d6d6bc80d22df57248a09f8a493f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97f19e847008fc645daf604f69b3ca8" id="r_ad97f19e847008fc645daf604f69b3ca8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#ad97f19e847008fc645daf604f69b3ca8">RasterizedVdl</a> (double l_start=0)</td></tr>
<tr class="memdesc:ad97f19e847008fc645daf604f69b3ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precalculates dVdl and creates a spline with the result. This is done to increase the runtime in large dimensional models.  <br /></td></tr>
<tr class="separator:ad97f19e847008fc645daf604f69b3ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56af7825d2984693798e9fb47f42724f" id="r_a56af7825d2984693798e9fb47f42724f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a56af7825d2984693798e9fb47f42724f">PrintVector</a> (std::vector&lt; double &gt; vec)</td></tr>
<tr class="memdesc:a56af7825d2984693798e9fb47f42724f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a vector.  <br /></td></tr>
<tr class="separator:a56af7825d2984693798e9fb47f42724f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c921fad8179d8aa3a50003c6617c16" id="r_ae5c921fad8179d8aa3a50003c6617c16"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#ae5c921fad8179d8aa3a50003c6617c16">Calc_dVdl</a> (double l)</td></tr>
<tr class="memdesc:ae5c921fad8179d8aa3a50003c6617c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \( \frac{dV}{dl} \) using the spline and potential derivatives.  <br /></td></tr>
<tr class="separator:ae5c921fad8179d8aa3a50003c6617c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40cc140b24cf064399ea0cdc27f8acf" id="r_ac40cc140b24cf064399ea0cdc27f8acf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#ac40cc140b24cf064399ea0cdc27f8acf">Calc_d2Vdl2</a> (double l)</td></tr>
<tr class="memdesc:ac40cc140b24cf064399ea0cdc27f8acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \( \frac{d^2V}{dl^2} \) using the spline and potential derivatives.  <br /></td></tr>
<tr class="separator:ac40cc140b24cf064399ea0cdc27f8acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fff8f4f6ab03f6186d75ab5c6f9971" id="r_a08fff8f4f6ab03f6186d75ab5c6f9971"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a08fff8f4f6ab03f6186d75ab5c6f9971">NormalForce</a> (const double &amp;l, const double &amp;dldrho, const std::vector&lt; double &gt; &amp;gradient)</td></tr>
<tr class="memdesc:a08fff8f4f6ab03f6186d75ab5c6f9971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated the normal force \( \vec{N} \) on a spline point.  <br /></td></tr>
<tr class="separator:a08fff8f4f6ab03f6186d75ab5c6f9971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea15c1789845d23ef2eb7497b764444" id="r_abea15c1789845d23ef2eb7497b764444"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#abea15c1789845d23ef2eb7497b764444">AuxFunctionDev</a> (const double &amp;rho, const std::vector&lt; double &gt; &amp;dvs, std::vector&lt; double &gt; &amp;aks)</td></tr>
<tr class="memdesc:abea15c1789845d23ef2eb7497b764444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function used in the Runge-Kutta 5th order adaptative step <a class="el" href="classBSMPT_1_1BounceActionInt.html#a8ca48bc968b6d7bb995cda9c91ef7d53">RK5_step</a>.  <br /></td></tr>
<tr class="separator:abea15c1789845d23ef2eb7497b764444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca48bc968b6d7bb995cda9c91ef7d53" id="r_a8ca48bc968b6d7bb995cda9c91ef7d53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a8ca48bc968b6d7bb995cda9c91ef7d53">RK5_step</a> (const std::vector&lt; double &gt; &amp;y, const std::vector&lt; double &gt; &amp;dydx, int n, float rho, float h, std::vector&lt; double &gt; &amp;yout, std::vector&lt; double &gt; &amp;yerr)</td></tr>
<tr class="memdesc:a8ca48bc968b6d7bb995cda9c91ef7d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runge-Kutta 5th order step.  <br /></td></tr>
<tr class="separator:a8ca48bc968b6d7bb995cda9c91ef7d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182d04c01c45437c738b542836f9c61a" id="r_a182d04c01c45437c738b542836f9c61a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a182d04c01c45437c738b542836f9c61a">BesselI</a> (double alpha, double x, int terms=100)</td></tr>
<tr class="memdesc:a182d04c01c45437c738b542836f9c61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified Bessel function \(I_\alpha (x) \) of the first kind.  <br /></td></tr>
<tr class="separator:a182d04c01c45437c738b542836f9c61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3556731a2b2d65ce8f380d568ffe7c35" id="r_a3556731a2b2d65ce8f380d568ffe7c35"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a3556731a2b2d65ce8f380d568ffe7c35">BesselJ</a> (double x, int terms=100)</td></tr>
<tr class="memdesc:a3556731a2b2d65ce8f380d568ffe7c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified Bessel function i \(J_1 (i x) \) of the first kind.  <br /></td></tr>
<tr class="separator:a3556731a2b2d65ce8f380d568ffe7c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12f8388f128a27fa120fd9fa05db29d" id="r_ac12f8388f128a27fa120fd9fa05db29d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#ac12f8388f128a27fa120fd9fa05db29d">ExactSolutionLin</a> (double l0, double l, double dVdl, double d2Vdl2)</td></tr>
<tr class="memdesc:ac12f8388f128a27fa120fd9fa05db29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates the 1D profile assuming \( \frac{dV}{dl} \) is a linear in l, i.e. \( \frac{dV}{dl} \approx dV + H (l - l_0) \). The solution is for \( \alpha = 2 \) is.  <br /></td></tr>
<tr class="separator:ac12f8388f128a27fa120fd9fa05db29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac931386046500da9c0d225143d1ddda8" id="r_ac931386046500da9c0d225143d1ddda8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#ac931386046500da9c0d225143d1ddda8">ExactSolutionFromMinimum</a> (double l)</td></tr>
<tr class="memdesc:ac931386046500da9c0d225143d1ddda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates the 1D profile assuming \( \frac{dV}{dl} \) is a linear in l, i.e. \( \frac{dV}{dl} \approx H (l - l_{min}) \). This correspondes to a purely qudratic potential.  <br /></td></tr>
<tr class="separator:ac931386046500da9c0d225143d1ddda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8d2c6c729e7176b35956106c0ee6d0" id="r_a3d8d2c6c729e7176b35956106c0ee6d0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a3d8d2c6c729e7176b35956106c0ee6d0">LogisticFunction</a> (const double &amp;x)</td></tr>
<tr class="memdesc:a3d8d2c6c729e7176b35956106c0ee6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logistic function with patched edges to account for numerical instability/nans.  <br /></td></tr>
<tr class="separator:a3d8d2c6c729e7176b35956106c0ee6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0520717fb16d52580754c3393ca687e8" id="r_a0520717fb16d52580754c3393ca687e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a0520717fb16d52580754c3393ca687e8">CalculateExactSolutionThreshold</a> (double MinError=1e100)</td></tr>
<tr class="memdesc:a0520717fb16d52580754c3393ca687e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate \(l_\text{threshold}\) that splits the two branches of analytical integration. This function works recursively until the error <b>MinError</b> is small enough or the integration step is too small to be numerically stable.  <br /></td></tr>
<tr class="separator:a0520717fb16d52580754c3393ca687e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424e464f9c73844c1b2bda179a45cc33" id="r_a424e464f9c73844c1b2bda179a45cc33"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a424e464f9c73844c1b2bda179a45cc33">ExactSolution</a> (double l0)</td></tr>
<tr class="memdesc:a424e464f9c73844c1b2bda179a45cc33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the 1D solution by comparing the ExactSolutionCons and <a class="el" href="classBSMPT_1_1BounceActionInt.html#ac12f8388f128a27fa120fd9fa05db29d">ExactSolutionLin</a> so that the analytical step is appropriate.  <br /></td></tr>
<tr class="separator:a424e464f9c73844c1b2bda179a45cc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9f932e0a78f2dd9b9d4462c2f4db3e" id="r_a5a9f932e0a78f2dd9b9d4462c2f4db3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a5a9f932e0a78f2dd9b9d4462c2f4db3e">BackwardsPropagation</a> ()</td></tr>
<tr class="memdesc:a5a9f932e0a78f2dd9b9d4462c2f4db3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is done to make sure that we can still find solution after path deformation. This propagates the spline into negative values (by extrapolating).  <br /></td></tr>
<tr class="separator:a5a9f932e0a78f2dd9b9d4462c2f4db3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c0f5b4f40a029fc5a349e6032b1f6f" id="r_ab6c0f5b4f40a029fc5a349e6032b1f6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#ab6c0f5b4f40a029fc5a349e6032b1f6f">IntegrateBounce</a> (double l0, <a class="el" href="classBSMPT_1_1BounceActionInt.html#a03efb7c6b290961c4892471f55e164af">UndershootOvershootStatus</a> &amp;conv, std::vector&lt; double &gt; &amp;rho, std::vector&lt; double &gt; &amp;l, std::vector&lt; double &gt; &amp;dl_drho, std::vector&lt; double &gt; &amp;d2l_drho2, int maxiter, double error, double eps_abs, double max_step=0)</td></tr>
<tr class="memdesc:ab6c0f5b4f40a029fc5a349e6032b1f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates 1D bounce equation once.  <br /></td></tr>
<tr class="separator:ab6c0f5b4f40a029fc5a349e6032b1f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885608a426afd615d80c13ef4a3c1172" id="r_a885608a426afd615d80c13ef4a3c1172"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a885608a426afd615d80c13ef4a3c1172">Solve1DBounce</a> (std::vector&lt; double &gt; &amp;rho, std::vector&lt; double &gt; &amp;l, std::vector&lt; double &gt; &amp;dl_drho, std::vector&lt; double &gt; &amp;d2l_drho2, double error=1e-7, int maxiter=100)</td></tr>
<tr class="memdesc:a885608a426afd615d80c13ef4a3c1172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary search using the overshooting/undershooting method to find the solution to the 1D bounce equation.  <br /></td></tr>
<tr class="separator:a885608a426afd615d80c13ef4a3c1172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6683142386513e53446e64d8e0ed8d2b" id="r_a6683142386513e53446e64d8e0ed8d2b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a6683142386513e53446e64d8e0ed8d2b">ReductorCalculator</a> (const double &amp;MaximumGradient)</td></tr>
<tr class="memdesc:a6683142386513e53446e64d8e0ed8d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the normalization of the force \( \vec{\phi} \rightarrow
\vec{\phi} + \vec{N}/reductor \). We have that \( reductor = \varepsilon
\max{\nabla V}/L \), where \( 10^{-4} \le \varepsilon \le 10^{-1} \) is a small parameter.  <br /></td></tr>
<tr class="separator:a6683142386513e53446e64d8e0ed8d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154d273ccc9e07d7f4df5bb512b0b85c" id="r_a154d273ccc9e07d7f4df5bb512b0b85c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a154d273ccc9e07d7f4df5bb512b0b85c">PathDeformationCheck</a> (std::vector&lt; double &gt; &amp;l, <a class="el" href="classtk_1_1spline.html">tk::spline</a> &amp;rho_l_spl)</td></tr>
<tr class="memdesc:a154d273ccc9e07d7f4df5bb512b0b85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the force in each point is sufficient small compared to the gradient in each point.  <br /></td></tr>
<tr class="separator:a154d273ccc9e07d7f4df5bb512b0b85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a14f225ae5c3f9e3c57135201bbf7a8" id="r_a3a14f225ae5c3f9e3c57135201bbf7a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a3a14f225ae5c3f9e3c57135201bbf7a8">SinglePathDeformation</a> (double &amp;stepsize, double &amp;reductor, std::vector&lt; double &gt; &amp;l, <a class="el" href="classtk_1_1spline.html">tk::spline</a> &amp;rho_l_spl, std::vector&lt; double &gt; &amp;l_fornextpath, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;best_path, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;next_path, double &amp;MaximumGradient, double &amp;MaximumForce, double &amp;MaximumRelativeError, double &amp;Maximum_dldrho, double &amp;PerpendicularGradient, MatrixXd &amp;inverseK, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;forces)</td></tr>
<tr class="memdesc:a3a14f225ae5c3f9e3c57135201bbf7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a single path deformation step.  <br /></td></tr>
<tr class="separator:a3a14f225ae5c3f9e3c57135201bbf7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdfa35af2862059236e530f1d2927ad" id="r_a1bdfa35af2862059236e530f1d2927ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a1bdfa35af2862059236e530f1d2927ad">PathDeformation</a> (std::vector&lt; double &gt; &amp;l, <a class="el" href="classtk_1_1spline.html">tk::spline</a> &amp;rho_l_spl)</td></tr>
<tr class="memdesc:a1bdfa35af2862059236e530f1d2927ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deforms the path minimizing the force \( \vec{N} \) without solving.  <br /></td></tr>
<tr class="separator:a1bdfa35af2862059236e530f1d2927ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f03c6ebd0211e5399aaef39e7507ef" id="r_a49f03c6ebd0211e5399aaef39e7507ef"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a49f03c6ebd0211e5399aaef39e7507ef">nChoosek</a> (unsigned n, unsigned k)</td></tr>
<tr class="memdesc:a49f03c6ebd0211e5399aaef39e7507ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of combinations of chosing k in n.  <br /></td></tr>
<tr class="separator:a49f03c6ebd0211e5399aaef39e7507ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96133411bb37aaaf86126b27d9eaa38" id="r_aa96133411bb37aaaf86126b27d9eaa38"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#aa96133411bb37aaaf86126b27d9eaa38">Bernstein</a> (int n, int nu, double x)</td></tr>
<tr class="memdesc:aa96133411bb37aaaf86126b27d9eaa38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the \( k^{th}\) Bernstein polynomial of degree \( n
\) at \( x \).  <br /></td></tr>
<tr class="separator:aa96133411bb37aaaf86126b27d9eaa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f81b5c6cb4abb0e6e37246125ab436" id="r_af7f81b5c6cb4abb0e6e37246125ab436"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#af7f81b5c6cb4abb0e6e37246125ab436">NormalForceBernstein</a> (const double &amp;dldrho, const std::vector&lt; double &gt; &amp;gradient, const std::vector&lt; double &gt; &amp;dphidl, const std::vector&lt; double &gt; &amp;d2phidl2)</td></tr>
<tr class="memdesc:af7f81b5c6cb4abb0e6e37246125ab436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the force vector \( \vec{N} \) of multiple path knots at the same time. Use in the path deformation algorithm.  <br /></td></tr>
<tr class="separator:af7f81b5c6cb4abb0e6e37246125ab436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac0cf8c4690ed66751551eaeececf18" id="r_a7ac0cf8c4690ed66751551eaeececf18"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a7ac0cf8c4690ed66751551eaeececf18">d2ldrho2</a> (double l, double rho, double dldrho)</td></tr>
<tr class="memdesc:a7ac0cf8c4690ed66751551eaeececf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \( \frac{d^2l}{d\rho^2} \).  <br /></td></tr>
<tr class="separator:a7ac0cf8c4690ed66751551eaeececf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21f937083bf8baae8441484e08690bc" id="r_ac21f937083bf8baae8441484e08690bc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#ac21f937083bf8baae8441484e08690bc">CalculateKineticTermAction</a> (const std::vector&lt; double &gt; &amp;rho, const <a class="el" href="classtk_1_1spline.html">tk::spline</a> &amp;dl_drho_spl)</td></tr>
<tr class="memdesc:ac21f937083bf8baae8441484e08690bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate kinect term of the action.  <br /></td></tr>
<tr class="separator:ac21f937083bf8baae8441484e08690bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79922c786a34c9d8f93524e5df22a54f" id="r_a79922c786a34c9d8f93524e5df22a54f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a79922c786a34c9d8f93524e5df22a54f">CalculatePotentialTermAction</a> (const std::vector&lt; double &gt; &amp;rho, const <a class="el" href="classtk_1_1spline.html">tk::spline</a> &amp;l_rho_spl)</td></tr>
<tr class="memdesc:a79922c786a34c9d8f93524e5df22a54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate potential term of the action.  <br /></td></tr>
<tr class="separator:a79922c786a34c9d8f93524e5df22a54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47f94d24b5403adefc09d5c35c8d743" id="r_aa47f94d24b5403adefc09d5c35c8d743"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#aa47f94d24b5403adefc09d5c35c8d743">CalculateAction</a> (double error=1e-6)</td></tr>
<tr class="memdesc:aa47f94d24b5403adefc09d5c35c8d743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the action of the bounce equation by deforming the given path and minimizing the normal force \( \vec{N} \) until it gets sufficiently small.  <br /></td></tr>
<tr class="separator:aa47f94d24b5403adefc09d5c35c8d743"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a01159002c3d65f5cc0f6a17bc9a20800" id="r_a01159002c3d65f5cc0f6a17bc9a20800"><td class="memItemLeft" align="right" valign="top"><a id="a01159002c3d65f5cc0f6a17bc9a20800" name="a01159002c3d65f5cc0f6a17bc9a20800"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dim</b> = -1</td></tr>
<tr class="memdesc:a01159002c3d65f5cc0f6a17bc9a20800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension of the VEV space. <br /></td></tr>
<tr class="separator:a01159002c3d65f5cc0f6a17bc9a20800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381293a29a38482cf1ac38ac3fdba3d1" id="r_a381293a29a38482cf1ac38ac3fdba3d1"><td class="memItemLeft" align="right" valign="top"><a id="a381293a29a38482cf1ac38ac3fdba3d1" name="a381293a29a38482cf1ac38ac3fdba3d1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Action</b> = -1</td></tr>
<tr class="memdesc:a381293a29a38482cf1ac38ac3fdba3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">either returns a -1 (if failed) or the value of the action <br /></td></tr>
<tr class="separator:a381293a29a38482cf1ac38ac3fdba3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a45d485ea861cdf709c5dc035f370ba" id="r_a5a45d485ea861cdf709c5dc035f370ba"><td class="memItemLeft" align="right" valign="top"><a id="a5a45d485ea861cdf709c5dc035f370ba" name="a5a45d485ea861cdf709c5dc035f370ba"></a>
<a class="el" href="classBSMPT_1_1BounceActionInt.html#ad0e65e97ac71874b3d21db50d8cbd1ff">ActionStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><b>StateOfBounceActionInt</b> = ActionStatus::NotCalculated</td></tr>
<tr class="memdesc:a5a45d485ea861cdf709c5dc035f370ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status of the Action calculation. <br /></td></tr>
<tr class="separator:a5a45d485ea861cdf709c5dc035f370ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fed28e7da1fa31fc2d832e6262203a" id="r_a94fed28e7da1fa31fc2d832e6262203a"><td class="memItemLeft" align="right" valign="top"><a id="a94fed28e7da1fa31fc2d832e6262203a" name="a94fed28e7da1fa31fc2d832e6262203a"></a>
<a class="el" href="classBSMPT_1_1BounceActionInt.html#a2f3feb2cc85873eb12de9c961c56314b">Integration1DStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><b>StateOf1DIntegration</b> = Integration1DStatus::NotConverged</td></tr>
<tr class="memdesc:a94fed28e7da1fa31fc2d832e6262203a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status of the 1D bounce solver. <br /></td></tr>
<tr class="separator:a94fed28e7da1fa31fc2d832e6262203a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b192a035855958fbbe882838598504" id="r_a31b192a035855958fbbe882838598504"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBSMPT_1_1BounceActionInt.html#ac2647c816f414debde47db27d5b52326">PathDeformationStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a31b192a035855958fbbe882838598504">StateOfPathDeformation</a></td></tr>
<tr class="memdesc:a31b192a035855958fbbe882838598504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status of the path deformation algorithm.  <br /></td></tr>
<tr class="separator:a31b192a035855958fbbe882838598504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67bd826a910bac7a4d85518d7b1d509" id="r_ae67bd826a910bac7a4d85518d7b1d509"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#ae67bd826a910bac7a4d85518d7b1d509">Alpha</a> = 2</td></tr>
<tr class="memdesc:ae67bd826a910bac7a4d85518d7b1d509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor produced by the spherical symmetry of the potential.  <br /></td></tr>
<tr class="separator:ae67bd826a910bac7a4d85518d7b1d509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f63d4147b28e0ebfd794b550cf999f6" id="r_a8f63d4147b28e0ebfd794b550cf999f6"><td class="memItemLeft" align="right" valign="top"><a id="a8f63d4147b28e0ebfd794b550cf999f6" name="a8f63d4147b28e0ebfd794b550cf999f6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>T</b> = -1</td></tr>
<tr class="memdesc:a8f63d4147b28e0ebfd794b550cf999f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temperature of the potential. Irrelevant but helpful. <br /></td></tr>
<tr class="separator:a8f63d4147b28e0ebfd794b550cf999f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85cf19a73f0016454db554d58d0d6b6" id="r_ab85cf19a73f0016454db554d58d0d6b6"><td class="memItemLeft" align="right" valign="top"><a id="ab85cf19a73f0016454db554d58d0d6b6" name="ab85cf19a73f0016454db554d58d0d6b6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxPathIntegrations</b></td></tr>
<tr class="memdesc:ab85cf19a73f0016454db554d58d0d6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of integration of the bounce. <br /></td></tr>
<tr class="separator:ab85cf19a73f0016454db554d58d0d6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff395a9011ebb0c3ae99ce2011dad96" id="r_a7ff395a9011ebb0c3ae99ce2011dad96"><td class="memItemLeft" align="right" valign="top"><a id="a7ff395a9011ebb0c3ae99ce2011dad96" name="a7ff395a9011ebb0c3ae99ce2011dad96"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxSinglePathDeformations</b> = 200</td></tr>
<tr class="memdesc:a7ff395a9011ebb0c3ae99ce2011dad96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of path deformations before integrating again. <br /></td></tr>
<tr class="separator:a7ff395a9011ebb0c3ae99ce2011dad96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f3c3e5dee34fcef55eeb52ca1327fe" id="r_a22f3c3e5dee34fcef55eeb52ca1327fe"><td class="memItemLeft" align="right" valign="top"><a id="a22f3c3e5dee34fcef55eeb52ca1327fe" name="a22f3c3e5dee34fcef55eeb52ca1327fe"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>rho_sol</b></td></tr>
<tr class="memdesc:a22f3c3e5dee34fcef55eeb52ca1327fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of \( \rho \) of the solution <br /></td></tr>
<tr class="separator:a22f3c3e5dee34fcef55eeb52ca1327fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb69807b222d5dc4490b97016c4e447" id="r_aaeb69807b222d5dc4490b97016c4e447"><td class="memItemLeft" align="right" valign="top"><a id="aaeb69807b222d5dc4490b97016c4e447" name="aaeb69807b222d5dc4490b97016c4e447"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>l_sol</b></td></tr>
<tr class="memdesc:aaeb69807b222d5dc4490b97016c4e447"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of \( l(\rho) \) of the solution <br /></td></tr>
<tr class="separator:aaeb69807b222d5dc4490b97016c4e447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3292f964a2fbddd162e96d01cdacdfec" id="r_a3292f964a2fbddd162e96d01cdacdfec"><td class="memItemLeft" align="right" valign="top"><a id="a3292f964a2fbddd162e96d01cdacdfec" name="a3292f964a2fbddd162e96d01cdacdfec"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dldrho_sol</b></td></tr>
<tr class="memdesc:a3292f964a2fbddd162e96d01cdacdfec"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of \( \frac{l}{\rho} \) of the solution <br /></td></tr>
<tr class="separator:a3292f964a2fbddd162e96d01cdacdfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e90221e7b5b887ae3fd7553e82493b" id="r_a69e90221e7b5b887ae3fd7553e82493b"><td class="memItemLeft" align="right" valign="top"><a id="a69e90221e7b5b887ae3fd7553e82493b" name="a69e90221e7b5b887ae3fd7553e82493b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>eps</b> = 0.01</td></tr>
<tr class="memdesc:a69e90221e7b5b887ae3fd7553e82493b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Step for the numerical derivative. <br /></td></tr>
<tr class="separator:a69e90221e7b5b887ae3fd7553e82493b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7dc2cea99022035fdb0457019445c3" id="r_a6c7dc2cea99022035fdb0457019445c3"><td class="memItemLeft" align="right" valign="top"><a id="a6c7dc2cea99022035fdb0457019445c3" name="a6c7dc2cea99022035fdb0457019445c3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>BernsteinDegree</b> = 10</td></tr>
<tr class="memdesc:a6c7dc2cea99022035fdb0457019445c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of basis function that are used + 1. <br /></td></tr>
<tr class="separator:a6c7dc2cea99022035fdb0457019445c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1537015cb4a851b7cb4b79f9d3c75edd" id="r_a1537015cb4a851b7cb4b79f9d3c75edd"><td class="memItemLeft" align="right" valign="top"><a id="a1537015cb4a851b7cb4b79f9d3c75edd" name="a1537015cb4a851b7cb4b79f9d3c75edd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>NumberPathKnots</b> = 50</td></tr>
<tr class="memdesc:a1537015cb4a851b7cb4b79f9d3c75edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">// Number of knots in the new path <br /></td></tr>
<tr class="separator:a1537015cb4a851b7cb4b79f9d3c75edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed8020e76f9bad1f767beae4348b3f0" id="r_afed8020e76f9bad1f767beae4348b3f0"><td class="memItemLeft" align="right" valign="top"><a id="afed8020e76f9bad1f767beae4348b3f0" name="afed8020e76f9bad1f767beae4348b3f0"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TrueVacuum</b></td></tr>
<tr class="memdesc:afed8020e76f9bad1f767beae4348b3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">True vacuum candidate. <br /></td></tr>
<tr class="separator:afed8020e76f9bad1f767beae4348b3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac837ce57dce3fddc5762588e66aac6c5" id="r_ac837ce57dce3fddc5762588e66aac6c5"><td class="memItemLeft" align="right" valign="top"><a id="ac837ce57dce3fddc5762588e66aac6c5" name="ac837ce57dce3fddc5762588e66aac6c5"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FalseVacuum</b></td></tr>
<tr class="memdesc:ac837ce57dce3fddc5762588e66aac6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">False vacuum. Should be the same as the last path knot. <br /></td></tr>
<tr class="separator:ac837ce57dce3fddc5762588e66aac6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ec54d4799c94ce10ddd8f1f83fc910" id="r_a32ec54d4799c94ce10ddd8f1f83fc910"><td class="memItemLeft" align="right" valign="top"><a id="a32ec54d4799c94ce10ddd8f1f83fc910" name="a32ec54d4799c94ce10ddd8f1f83fc910"></a>
std::function&lt; double(std::vector&lt; double &gt;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>V</b></td></tr>
<tr class="memdesc:a32ec54d4799c94ce10ddd8f1f83fc910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Potential of the class. <br /></td></tr>
<tr class="separator:a32ec54d4799c94ce10ddd8f1f83fc910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0debf1c85acfb2ae72566892c055c5b9" id="r_a0debf1c85acfb2ae72566892c055c5b9"><td class="memItemLeft" align="right" valign="top"><a id="a0debf1c85acfb2ae72566892c055c5b9" name="a0debf1c85acfb2ae72566892c055c5b9"></a>
std::function&lt; std::vector&lt; double &gt;(std::vector&lt; double &gt;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dV</b></td></tr>
<tr class="memdesc:a0debf1c85acfb2ae72566892c055c5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Potential gradient of the class, can be either numerical or analytical. <br /></td></tr>
<tr class="separator:a0debf1c85acfb2ae72566892c055c5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb378b0fcb71d59f60ff85311273cd73" id="r_acb378b0fcb71d59f60ff85311273cd73"><td class="memItemLeft" align="right" valign="top">std::function&lt; std::vector&lt; std::vector&lt; double &gt; &gt;(std::vector&lt; double &gt;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSMPT_1_1BounceActionInt.html#acb378b0fcb71d59f60ff85311273cd73">Hessian</a></td></tr>
<tr class="memdesc:acb378b0fcb71d59f60ff85311273cd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Potential hessian of the class, completly numerical.  <br /></td></tr>
<tr class="separator:acb378b0fcb71d59f60ff85311273cd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfc853d0c4752c0a0e4fe78c5957123" id="r_a0dfc853d0c4752c0a0e4fe78c5957123"><td class="memItemLeft" align="right" valign="top"><a id="a0dfc853d0c4752c0a0e4fe78c5957123" name="a0dfc853d0c4752c0a0e4fe78c5957123"></a>
std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>InitPath</b></td></tr>
<tr class="memdesc:a0dfc853d0c4752c0a0e4fe78c5957123"><td class="mdescLeft">&#160;</td><td class="mdescRight">First path given to class. <br /></td></tr>
<tr class="separator:a0dfc853d0c4752c0a0e4fe78c5957123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813897fef30f310ac68febb1d61dd691" id="r_a813897fef30f310ac68febb1d61dd691"><td class="memItemLeft" align="right" valign="top"><a id="a813897fef30f310ac68febb1d61dd691" name="a813897fef30f310ac68febb1d61dd691"></a>
std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Path</b></td></tr>
<tr class="memdesc:a813897fef30f310ac68febb1d61dd691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current class path, can be changed by <a class="el" href="classBSMPT_1_1BounceActionInt.html#a1bdfa35af2862059236e530f1d2927ad">PathDeformation</a>. <br /></td></tr>
<tr class="separator:a813897fef30f310ac68febb1d61dd691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4330ab52d72bb7a0a9a2ae55267021" id="r_abc4330ab52d72bb7a0a9a2ae55267021"><td class="memItemLeft" align="right" valign="top"><a id="abc4330ab52d72bb7a0a9a2ae55267021" name="abc4330ab52d72bb7a0a9a2ae55267021"></a>
<a class="el" href="classcvspline.html">cvspline</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Spline</b></td></tr>
<tr class="memdesc:abc4330ab52d72bb7a0a9a2ae55267021"><td class="mdescLeft">&#160;</td><td class="mdescRight">We describe the tunneling path using a cubid spline. The parameterization is the length along the spline. <br /></td></tr>
<tr class="separator:abc4330ab52d72bb7a0a9a2ae55267021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad124704710a9a8d66bf54f4b37270467" id="r_ad124704710a9a8d66bf54f4b37270467"><td class="memItemLeft" align="right" valign="top"><a id="ad124704710a9a8d66bf54f4b37270467" name="ad124704710a9a8d66bf54f4b37270467"></a>
<a class="el" href="classtk_1_1spline.html">tk::spline</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RasterizeddVdl</b></td></tr>
<tr class="memdesc:ad124704710a9a8d66bf54f4b37270467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spline used to save \( \frac{dV}{dl} \). <br /></td></tr>
<tr class="separator:ad124704710a9a8d66bf54f4b37270467"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a1d402c0928fdea994ead22d1bffd1c87" id="r_a1d402c0928fdea994ead22d1bffd1c87"><td class="memItemLeft" align="right" valign="top"><a id="a1d402c0928fdea994ead22d1bffd1c87" name="a1d402c0928fdea994ead22d1bffd1c87"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>UndershotOnce</b> = false</td></tr>
<tr class="memdesc:a1d402c0928fdea994ead22d1bffd1c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records if overshoot/undershoot method undershots at least once. <br /></td></tr>
<tr class="separator:a1d402c0928fdea994ead22d1bffd1c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6705875b5f993b55c6fb35a9876def58" id="r_a6705875b5f993b55c6fb35a9876def58"><td class="memItemLeft" align="right" valign="top"><a id="a6705875b5f993b55c6fb35a9876def58" name="a6705875b5f993b55c6fb35a9876def58"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>OvershotOnce</b> = false</td></tr>
<tr class="memdesc:a6705875b5f993b55c6fb35a9876def58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records if overshoot/undershoot method overshots at least once. <br /></td></tr>
<tr class="separator:a6705875b5f993b55c6fb35a9876def58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350fb3ab13613afa06c9efe6da9a72ea" id="r_a350fb3ab13613afa06c9efe6da9a72ea"><td class="memItemLeft" align="right" valign="top"><a id="a350fb3ab13613afa06c9efe6da9a72ea" name="a350fb3ab13613afa06c9efe6da9a72ea"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>TrueVacuumHessian</b></td></tr>
<tr class="memdesc:a350fb3ab13613afa06c9efe6da9a72ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of d2Vdl^2 near the true vacuum. <br /></td></tr>
<tr class="separator:a350fb3ab13613afa06c9efe6da9a72ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fe0a80ad1f5a2184fdf902d66a0859" id="r_ad2fe0a80ad1f5a2184fdf902d66a0859"><td class="memItemLeft" align="right" valign="top"><a id="ad2fe0a80ad1f5a2184fdf902d66a0859" name="ad2fe0a80ad1f5a2184fdf902d66a0859"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Initial_lmin</b></td></tr>
<tr class="memdesc:ad2fe0a80ad1f5a2184fdf902d66a0859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the value of backwards propagation. <br /></td></tr>
<tr class="separator:ad2fe0a80ad1f5a2184fdf902d66a0859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6475be53a29a92745279a76cace664d4" id="r_a6475be53a29a92745279a76cace664d4"><td class="memItemLeft" align="right" valign="top"><a id="a6475be53a29a92745279a76cace664d4" name="a6475be53a29a92745279a76cace664d4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Vfalse</b></td></tr>
<tr class="memdesc:a6475be53a29a92745279a76cace664d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Potential at the false vacuum in the unshifted potential (in the shifted Vfalse = 0) <br /></td></tr>
<tr class="separator:a6475be53a29a92745279a76cace664d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e8cc2ab302bbad5811e535e0900547" id="r_a59e8cc2ab302bbad5811e535e0900547"><td class="memItemLeft" align="right" valign="top"><a id="a59e8cc2ab302bbad5811e535e0900547" name="a59e8cc2ab302bbad5811e535e0900547"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>l0_minus_lmin</b></td></tr>
<tr class="memdesc:a59e8cc2ab302bbad5811e535e0900547"><td class="mdescLeft">&#160;</td><td class="mdescRight">l0 - Initial_lmin for solutions starting very near the true vacuum <br /></td></tr>
<tr class="separator:a59e8cc2ab302bbad5811e535e0900547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9682369d1650284322a9d475ada206a" id="r_ad9682369d1650284322a9d475ada206a"><td class="memItemLeft" align="right" valign="top"><a id="ad9682369d1650284322a9d475ada206a" name="ad9682369d1650284322a9d475ada206a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>PathDeformationConvergedWithout1D</b> = false</td></tr>
<tr class="memdesc:ad9682369d1650284322a9d475ada206a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if path deformation reached the desired results without solving the 1D equation one more time. <br /></td></tr>
<tr class="separator:ad9682369d1650284322a9d475ada206a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095ef140bf0243f9808721aae53c4039" id="r_a095ef140bf0243f9808721aae53c4039"><td class="memItemLeft" align="right" valign="top"><a id="a095ef140bf0243f9808721aae53c4039" name="a095ef140bf0243f9808721aae53c4039"></a>
std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ExactSolutionThreshold</b></td></tr>
<tr class="memdesc:a095ef140bf0243f9808721aae53c4039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lmin - L0 that splits between the two branches of the H &gt; 0 analytical solution. If unset, we only use the linear approximation. <br /></td></tr>
<tr class="separator:a095ef140bf0243f9808721aae53c4039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79ce0dd9cb514df6cce2e8e64f932cd" id="r_aa79ce0dd9cb514df6cce2e8e64f932cd"><td class="memItemLeft" align="right" valign="top"><a id="aa79ce0dd9cb514df6cce2e8e64f932cd" name="aa79ce0dd9cb514df6cce2e8e64f932cd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>FractionOfThePathExact</b> = 1e-4</td></tr>
<tr class="memdesc:aa79ce0dd9cb514df6cce2e8e64f932cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">First guess of l(rho) - l0 used to to integrate in the analytical solution. Can be decreased if the error is too high. <br /></td></tr>
<tr class="separator:aa79ce0dd9cb514df6cce2e8e64f932cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="addd14beac6a70fe7152ec3ecd80592b6" name="addd14beac6a70fe7152ec3ecd80592b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd14beac6a70fe7152ec3ecd80592b6">&#9670;&#160;</a></span>BounceActionInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSMPT::BounceActionInt::BounceActionInt </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td>
          <td class="paramname"><em>InitPath_In</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>TrueVacuum_In</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>FalseVacuum_In</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(std::vector&lt; double &gt;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>V_In</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::vector&lt; double &gt;(std::vector&lt; double &gt;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>dV_In</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T_In</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MaxPathIntegrations_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new Bounce Action Int object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_path</td><td>is the initial path guess </td></tr>
    <tr><td class="paramname">TrueVacuumIn</td><td>is the true vacuum candidate of the potential </td></tr>
    <tr><td class="paramname">FalseVacuumIn</td><td>is the false vacuum </td></tr>
    <tr><td class="paramname">V</td><td>is the class potential </td></tr>
    <tr><td class="paramname">dV</td><td>is the class gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4511691cd660bf2efa86ba7869bb4d14" name="a4511691cd660bf2efa86ba7869bb4d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4511691cd660bf2efa86ba7869bb4d14">&#9670;&#160;</a></span>BounceActionInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSMPT::BounceActionInt::BounceActionInt </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td>
          <td class="paramname"><em>InitPath_In</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>TrueVacuum_In</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>FalseVacuum_In</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(std::vector&lt; double &gt;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>V_In</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T_In</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MaxPathIntegrations_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new Bounce Action Int object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_path</td><td>is the initial path guess </td></tr>
    <tr><td class="paramname">TrueVacuumIn</td><td>is the true vacuum candidate of the potential </td></tr>
    <tr><td class="paramname">FalseVacuumIn</td><td>is the false vacuum </td></tr>
    <tr><td class="paramname">V</td><td>is the class potential </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abea15c1789845d23ef2eb7497b764444" name="abea15c1789845d23ef2eb7497b764444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea15c1789845d23ef2eb7497b764444">&#9670;&#160;</a></span>AuxFunctionDev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BSMPT::BounceActionInt::AuxFunctionDev </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>aks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary function used in the Runge-Kutta 5th order adaptative step <a class="el" href="classBSMPT_1_1BounceActionInt.html#a8ca48bc968b6d7bb995cda9c91ef7d53">RK5_step</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rho</td><td>is the integration variable \( \rho \). </td></tr>
    <tr><td class="paramname">dvs</td><td>are the functions values. </td></tr>
    <tr><td class="paramname">aks</td><td>are used to return the function derivatives. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a9f932e0a78f2dd9b9d4462c2f4db3e" name="a5a9f932e0a78f2dd9b9d4462c2f4db3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9f932e0a78f2dd9b9d4462c2f4db3e">&#9670;&#160;</a></span>BackwardsPropagation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BSMPT::BounceActionInt::BackwardsPropagation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is done to make sure that we can still find solution after path deformation. This propagates the spline into negative values (by extrapolating). </p>
<dl class="section return"><dt>Returns</dt><dd>double negative or zero value. </dd></dl>

</div>
</div>
<a id="aa96133411bb37aaaf86126b27d9eaa38" name="aa96133411bb37aaaf86126b27d9eaa38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96133411bb37aaaf86126b27d9eaa38">&#9670;&#160;</a></span>Bernstein()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BSMPT::BounceActionInt::Bernstein </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the \( k^{th}\) Bernstein polynomial of degree \( n
\) at \( x \). </p>
<p>\( B_{\nu,n}(x) = {n \choose \nu} x^\nu (1-x)^{n-\nu} \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Bernstein degree. </td></tr>
    <tr><td class="paramname">nu</td><td>Bernstein basis function, \( 0 \leq \nu \leq n \). </td></tr>
    <tr><td class="paramname">x</td><td>is the independent parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double \( B_{\nu,n}(x) \). </dd></dl>

</div>
</div>
<a id="a182d04c01c45437c738b542836f9c61a" name="a182d04c01c45437c738b542836f9c61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182d04c01c45437c738b542836f9c61a">&#9670;&#160;</a></span>BesselI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BSMPT::BounceActionInt::BesselI </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>terms</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modified Bessel function \(I_\alpha (x) \) of the first kind. </p>
<p>\(I_\alpha (x) = \sum_{m=0}^\infty \frac{1}{m! \Gamma(m + \alpha + 1)}
\left(\frac{x}{2}\right)^{2m + \alpha}  \)</p>
<p>The convergence should be quite fast. We use as many terms to get the last term to impact the result in \( 10^{-15}\) (relatively). The default maximum number of terms is 50.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>is an complex number. </td></tr>
    <tr><td class="paramname">x</td><td>where to calculate the Bessel function. </td></tr>
    <tr><td class="paramname">terms</td><td>are the maximum number of terms allowed in the calculation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double returns \(I_\alpha (x) \) </dd></dl>

</div>
</div>
<a id="a3556731a2b2d65ce8f380d568ffe7c35" name="a3556731a2b2d65ce8f380d568ffe7c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3556731a2b2d65ce8f380d568ffe7c35">&#9670;&#160;</a></span>BesselJ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BSMPT::BounceActionInt::BesselJ </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>terms</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modified Bessel function i \(J_1 (i x) \) of the first kind. </p>
<p>\(i J_1 (i x) = i \sum_{m=0}^\infty (-1)^{m + 1} \frac{1}{m! \Gamma(m +
\alpha + 1)} \left(\frac{x}{2}\right)^{2m + \alpha}  \)</p>
<p>The convergence should be quite fast. We use as many terms to get the last term to impact the result in \( 10^{-15}\) (relatively). The default maximum number of terms is 50.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>is an complex number. </td></tr>
    <tr><td class="paramname">x</td><td>where to calculate the Bessel function. </td></tr>
    <tr><td class="paramname">terms</td><td>are the maximum number of terms allowed in the calculation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double returns \(I_\alpha (x) \) </dd></dl>

</div>
</div>
<a id="ac40cc140b24cf064399ea0cdc27f8acf" name="ac40cc140b24cf064399ea0cdc27f8acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40cc140b24cf064399ea0cdc27f8acf">&#9670;&#160;</a></span>Calc_d2Vdl2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BSMPT::BounceActionInt::Calc_d2Vdl2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \( \frac{d^2V}{dl^2} \) using the spline and potential derivatives. </p>
<p>\( \frac{d^2V}{dl^2}  = \nabla V(\vec{\phi}) \cdot  \frac{d^2
\vec{\phi}}{dl^2} +  \left(\frac{d\vec{\phi}}{dl}\right)^T H(\vec{\phi})
\frac{d\vec{\phi}}{dl} \)</p>
<dl class="section return"><dt>Returns</dt><dd>double Returns \( \frac{d^2V}{dl^2}  \) </dd></dl>

</div>
</div>
<a id="ae5c921fad8179d8aa3a50003c6617c16" name="ae5c921fad8179d8aa3a50003c6617c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c921fad8179d8aa3a50003c6617c16">&#9670;&#160;</a></span>Calc_dVdl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BSMPT::BounceActionInt::Calc_dVdl </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \( \frac{dV}{dl} \) using the spline and potential derivatives. </p>
<p>\( \frac{dV}{dl}  = \frac{\partial V}{\partial \vec{\phi}} \cdot  \frac{d
\vec{\phi}}{dl} = \nabla V(\vec{\phi}) \cdot  \frac{d
\vec{\phi}}{dl} \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>Spline parameterization point where \( \frac{dV}{dl} \) is calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double Returns \( \frac{dV}{dl} \) </dd></dl>

</div>
</div>
<a id="aa47f94d24b5403adefc09d5c35c8d743" name="aa47f94d24b5403adefc09d5c35c8d743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47f94d24b5403adefc09d5c35c8d743">&#9670;&#160;</a></span>CalculateAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BSMPT::BounceActionInt::CalculateAction </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>error</em> = <code>1e-6</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the action of the bounce equation by deforming the given path and minimizing the normal force \( \vec{N} \) until it gets sufficiently small. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>is the acceptance of undershoot/overshoot method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0520717fb16d52580754c3393ca687e8" name="a0520717fb16d52580754c3393ca687e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0520717fb16d52580754c3393ca687e8">&#9670;&#160;</a></span>CalculateExactSolutionThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BSMPT::BounceActionInt::CalculateExactSolutionThreshold </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>MinError</em> = <code>1e100</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate \(l_\text{threshold}\) that splits the two branches of analytical integration. This function works recursively until the error <b>MinError</b> is small enough or the integration step is too small to be numerically stable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MinError</td><td>Lowest error found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac21f937083bf8baae8441484e08690bc" name="ac21f937083bf8baae8441484e08690bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21f937083bf8baae8441484e08690bc">&#9670;&#160;</a></span>CalculateKineticTermAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BSMPT::BounceActionInt::CalculateKineticTermAction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1spline.html">tk::spline</a> &amp;&#160;</td>
          <td class="paramname"><em>dl_drho_spl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate kinect term of the action. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rho</td><td>list of rho coming from the integration </td></tr>
    <tr><td class="paramname">dl_drho_spl</td><td>Spline of \(\frac{dl(\rho)}{d\rho}\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double kinetic part of the action </dd></dl>

</div>
</div>
<a id="a79922c786a34c9d8f93524e5df22a54f" name="a79922c786a34c9d8f93524e5df22a54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79922c786a34c9d8f93524e5df22a54f">&#9670;&#160;</a></span>CalculatePotentialTermAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BSMPT::BounceActionInt::CalculatePotentialTermAction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1spline.html">tk::spline</a> &amp;&#160;</td>
          <td class="paramname"><em>l_rho_spl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate potential term of the action. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rho</td><td>list of rho coming from the integration </td></tr>
    <tr><td class="paramname">l_rho_spl</td><td>Spline of \(l(\rho)\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double potential part of the action </dd></dl>

</div>
</div>
<a id="a7ac0cf8c4690ed66751551eaeececf18" name="a7ac0cf8c4690ed66751551eaeececf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac0cf8c4690ed66751551eaeececf18">&#9670;&#160;</a></span>d2ldrho2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BSMPT::BounceActionInt::d2ldrho2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dldrho</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \( \frac{d^2l}{d\rho^2} \). </p>
<p>\( \frac{d^2l}{d\rho^2} = \frac{dV}{dl} -
\frac{\alpha}{\rho}\frac{dl}{d\rho}\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>\( = l(\rho) \) </td></tr>
    <tr><td class="paramname">rho</td><td>where we want to calculate. </td></tr>
    <tr><td class="paramname">dldrho</td><td>\( = \frac{dl(\rho)}{d\rho} \) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double \( \frac{d^2l}{d\rho^2} \) at \( \rho \) </dd></dl>

</div>
</div>
<a id="a424e464f9c73844c1b2bda179a45cc33" name="a424e464f9c73844c1b2bda179a45cc33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424e464f9c73844c1b2bda179a45cc33">&#9670;&#160;</a></span>ExactSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; BSMPT::BounceActionInt::ExactSolution </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the 1D solution by comparing the ExactSolutionCons and <a class="el" href="classBSMPT_1_1BounceActionInt.html#ac12f8388f128a27fa120fd9fa05db29d">ExactSolutionLin</a> so that the analytical step is appropriate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l0</td><td>starting point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;double&gt; </dd></dl>

</div>
</div>
<a id="ac931386046500da9c0d225143d1ddda8" name="ac931386046500da9c0d225143d1ddda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac931386046500da9c0d225143d1ddda8">&#9670;&#160;</a></span>ExactSolutionFromMinimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; BSMPT::BounceActionInt::ExactSolutionFromMinimum </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrates the 1D profile assuming \( \frac{dV}{dl} \) is a linear in l, i.e. \( \frac{dV}{dl} \approx H (l - l_{min}) \). This correspondes to a purely qudratic potential. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>is the integration final point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;double&gt; </dd></dl>

</div>
</div>
<a id="ac12f8388f128a27fa120fd9fa05db29d" name="ac12f8388f128a27fa120fd9fa05db29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12f8388f128a27fa120fd9fa05db29d">&#9670;&#160;</a></span>ExactSolutionLin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; BSMPT::BounceActionInt::ExactSolutionLin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dVdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d2Vdl2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrates the 1D profile assuming \( \frac{dV}{dl} \) is a linear in l, i.e. \( \frac{dV}{dl} \approx dV + H (l - l_0) \). The solution is for \( \alpha = 2 \) is. </p>
<p>\( l(\rho) = l_0 - \frac{dV}{H} +
\frac{dV}{H^{3/2}}\frac{\sinh(\rho\sqrt{H})}{\rho} \)</p>
<p>and the solution for \( \alpha = 3 \) is</p>
<p>\( l(\rho) = l_0 - \frac{dV}{H} + \frac{2 dV}{H^{3/2}} \frac{I_\alpha(\rho
\sqrt{H})}{\rho}\)</p>
<p>where \( I_\alpha(\rho) \) is the modified Bessel function of the first kind.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l0</td><td>is the integration starting point. </td></tr>
    <tr><td class="paramname">l</td><td>is the integration final point. </td></tr>
    <tr><td class="paramname">dVdl</td><td>\( \frac{dV}{dl} \) at \( l_0 \). </td></tr>
    <tr><td class="paramname">d2Vdl2</td><td>\( \frac{d^2V}{dl^2} \) at \( l_0 \). </td></tr>
    <tr><td class="paramname">maxiter</td><td>Maximum iteration when calculating \( \rho(l) \). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;double&gt; </dd></dl>

</div>
</div>
<a id="ab6c0f5b4f40a029fc5a349e6032b1f6f" name="ab6c0f5b4f40a029fc5a349e6032b1f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c0f5b4f40a029fc5a349e6032b1f6f">&#9670;&#160;</a></span>IntegrateBounce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BSMPT::BounceActionInt::IntegrateBounce </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBSMPT_1_1BounceActionInt.html#a03efb7c6b290961c4892471f55e164af">UndershootOvershootStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dl_drho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>d2l_drho2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps_abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_step</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrates 1D bounce equation once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l0</td><td>is the starting value. </td></tr>
    <tr><td class="paramname">conv</td><td>checks type of convergence. Converged. Undershoot. Overshoot. </td></tr>
    <tr><td class="paramname">rho</td><td>vector of integration variable \( \rho \) steps. </td></tr>
    <tr><td class="paramname">l</td><td>vector of variable \( l \) steps. </td></tr>
    <tr><td class="paramname">dl_drho</td><td>vector of variable \( \frac{dl}{d\rho} \) steps. </td></tr>
    <tr><td class="paramname">d2l_drho2</td><td>vector of variable \( \frac{d^2l}{d\rho^2} \) steps. </td></tr>
    <tr><td class="paramname">maxiter</td><td>is the maximum integration steps. </td></tr>
    <tr><td class="paramname">error</td><td>is the acceptance of undershoot/overshoot. </td></tr>
    <tr><td class="paramname">eps_abs</td><td>is used to control the step size error (RK4 vs RK5). </td></tr>
    <tr><td class="paramname">max_step</td><td>in the case you want to set a maximum step size in \( \rho
\). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d8d2c6c729e7176b35956106c0ee6d0" name="a3d8d2c6c729e7176b35956106c0ee6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8d2c6c729e7176b35956106c0ee6d0">&#9670;&#160;</a></span>LogisticFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BSMPT::BounceActionInt::LogisticFunction </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logistic function with patched edges to account for numerical instability/nans. </p>
<p>\( \text{LogisticFunction}(x)=\begin{cases}1,\quad x\ge10\\0,\quad x\le
-10\\\frac{1}{1+e^{-x}},\quad\text{otherwise}\end{cases} \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>independent variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double logistic function at at x </dd></dl>

</div>
</div>
<a id="a49f03c6ebd0211e5399aaef39e7507ef" name="a49f03c6ebd0211e5399aaef39e7507ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f03c6ebd0211e5399aaef39e7507ef">&#9670;&#160;</a></span>nChoosek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned BSMPT::BounceActionInt::nChoosek </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of combinations of chosing k in n. </p>
<p>\( {n \choose k}  = \frac{n!}{k!(n-k)!}\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td></td></tr>
    <tr><td class="paramname">k</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned </dd></dl>

</div>
</div>
<a id="a08fff8f4f6ab03f6186d75ab5c6f9971" name="a08fff8f4f6ab03f6186d75ab5c6f9971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fff8f4f6ab03f6186d75ab5c6f9971">&#9670;&#160;</a></span>NormalForce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; BSMPT::BounceActionInt::NormalForce </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>dldrho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculated the normal force \( \vec{N} \) on a spline point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>is the spline parameter where the force is calculated. </td></tr>
    <tr><td class="paramname">dldrho</td><td>is \( \frac{dl}{d\rho}\). </td></tr>
    <tr><td class="paramname">gradient</td><td>is the gradient evaluated at spline parameter l. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;double&gt; is the \( \vec{N} \) at spline parameter l. </dd></dl>

</div>
</div>
<a id="af7f81b5c6cb4abb0e6e37246125ab436" name="af7f81b5c6cb4abb0e6e37246125ab436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f81b5c6cb4abb0e6e37246125ab436">&#9670;&#160;</a></span>NormalForceBernstein()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; BSMPT::BounceActionInt::NormalForceBernstein </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>dldrho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dphidl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>d2phidl2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the force vector \( \vec{N} \) of multiple path knots at the same time. Use in the path deformation algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dldrho</td><td>is the vector of \( \frac{dl}{d\rho} \) values from the solution. </td></tr>
    <tr><td class="paramname">gradient</td><td>is the vector of \( \nabla(\vec{\phi}(l)) \) values from the solution. </td></tr>
    <tr><td class="paramname">dphidl</td><td>is the vector of \( \frac{d\vec{\phi}}{dl} \) values from the solution. </td></tr>
    <tr><td class="paramname">d2phidl2</td><td>is the vector of \( \frac{d^2\vec{\phi}}{dl^2} \) values from the solution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;double&gt; list of force vectors \( \vec{N} \) applied to each path knot. </dd></dl>

</div>
</div>
<a id="a1bdfa35af2862059236e530f1d2927ad" name="a1bdfa35af2862059236e530f1d2927ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdfa35af2862059236e530f1d2927ad">&#9670;&#160;</a></span>PathDeformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BSMPT::BounceActionInt::PathDeformation </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtk_1_1spline.html">tk::spline</a> &amp;&#160;</td>
          <td class="paramname"><em>rho_l_spl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deforms the path minimizing the force \( \vec{N} \) without solving. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>is the vector of \( \rho \) values from the solution </td></tr>
    <tr><td class="paramname">rho_l_spl</td><td><a class="el" href="classtk_1_1spline.html">tk::spline</a> of \( \rho(l) \) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a154d273ccc9e07d7f4df5bb512b0b85c" name="a154d273ccc9e07d7f4df5bb512b0b85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154d273ccc9e07d7f4df5bb512b0b85c">&#9670;&#160;</a></span>PathDeformationCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BSMPT::BounceActionInt::PathDeformationCheck </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtk_1_1spline.html">tk::spline</a> &amp;&#160;</td>
          <td class="paramname"><em>rho_l_spl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the force in each point is sufficient small compared to the gradient in each point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>list of spline parameter \( l \) of the knots </td></tr>
    <tr><td class="paramname">rho_l_spl</td><td>list of \( \frac{dl}{d\rho}\) of the knots </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if converged </dd>
<dd>
false if not converged </dd></dl>

</div>
</div>
<a id="a56af7825d2984693798e9fb47f42724f" name="a56af7825d2984693798e9fb47f42724f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56af7825d2984693798e9fb47f42724f">&#9670;&#160;</a></span>PrintVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BSMPT::BounceActionInt::PrintVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Vector to be printed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad97f19e847008fc645daf604f69b3ca8" name="ad97f19e847008fc645daf604f69b3ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97f19e847008fc645daf604f69b3ca8">&#9670;&#160;</a></span>RasterizedVdl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BSMPT::BounceActionInt::RasterizedVdl </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l_start</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Precalculates dVdl and creates a spline with the result. This is done to increase the runtime in large dimensional models. </p>
<ul>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l_start</td><td>is the starting position produced in the backwardspropagation part </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a6683142386513e53446e64d8e0ed8d2b" name="a6683142386513e53446e64d8e0ed8d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6683142386513e53446e64d8e0ed8d2b">&#9670;&#160;</a></span>ReductorCalculator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BSMPT::BounceActionInt::ReductorCalculator </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>MaximumGradient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the normalization of the force \( \vec{\phi} \rightarrow
\vec{\phi} + \vec{N}/reductor \). We have that \( reductor = \varepsilon
\max{\nabla V}/L \), where \( 10^{-4} \le \varepsilon \le 10^{-1} \) is a small parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MaximumGradient</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double </dd></dl>

</div>
</div>
<a id="a8ca48bc968b6d7bb995cda9c91ef7d53" name="a8ca48bc968b6d7bb995cda9c91ef7d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca48bc968b6d7bb995cda9c91ef7d53">&#9670;&#160;</a></span>RK5_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BSMPT::BounceActionInt::RK5_step </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dydx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>yerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runge-Kutta 5th order step. </p>
<p>Although the Runge-Kutta methods are valid for \( y&#39; =
f(t,y) \) integration one can generalize the method for higher order ODE using auxiliary functions. One can write \( y&#39;&#39; = f(t,y, y&#39;) \) as</p>
<ul>
<li>\( y&#39; = m \)</li>
<li>\( m&#39; = f(t, y, m) \)</li>
</ul>
<p>linearizing the ODE system allowing the application of Runge-Kutta method to each one.</p>
<p>This method takes a 5th order Runge-Kutta step that can be embedded into a 4th order Runge-Kutta step. By comparing the result of the 4th and 5th order we can control the error within our calculation by adjusting the step size accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>function values \( \{y(\rho_i), m(\rho_i) \} \). </td></tr>
    <tr><td class="paramname">dydx</td><td>function derivatives \( \{y&#39;(\rho_i), m&#39;(\rho_i) \} \). </td></tr>
    <tr><td class="paramname">n</td><td>is the number of linearizations, i.e. 2. </td></tr>
    <tr><td class="paramname">rho</td><td>is the integration variable \( \rho \). </td></tr>
    <tr><td class="paramname">h</td><td>is the step size. </td></tr>
    <tr><td class="paramname">yout</td><td>is the 5th order Runge-Kutta integration result. </td></tr>
    <tr><td class="paramname">yerr</td><td>is the difference between the 4th order and 5th order Runge-Kutta result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73d6d6bc80d22df57248a09f8a493f94" name="a73d6d6bc80d22df57248a09f8a493f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d6d6bc80d22df57248a09f8a493f94">&#9670;&#160;</a></span>SetPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BSMPT::BounceActionInt::SetPath </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td>
          <td class="paramname"><em>InitPath_In</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used set the path of the class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_path</td><td>Knots that are used to describe the path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a14f225ae5c3f9e3c57135201bbf7a8" name="a3a14f225ae5c3f9e3c57135201bbf7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a14f225ae5c3f9e3c57135201bbf7a8">&#9670;&#160;</a></span>SinglePathDeformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BSMPT::BounceActionInt::SinglePathDeformation </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>stepsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>reductor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtk_1_1spline.html">tk::spline</a> &amp;&#160;</td>
          <td class="paramname"><em>rho_l_spl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_fornextpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>best_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>next_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>MaximumGradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>MaximumForce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>MaximumRelativeError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>Maximum_dldrho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>PerpendicularGradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>inverseK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>forces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a single path deformation step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stepsize</td><td>\( \varepsilon \) </td></tr>
    <tr><td class="paramname">reductor</td><td>is the reductor </td></tr>
    <tr><td class="paramname">l</td><td>list of \( l \) at the knots of the old solution </td></tr>
    <tr><td class="paramname">rho_l_spl</td><td>list of \( \frac{dl}{d\rho} \) at the knots of the old solution </td></tr>
    <tr><td class="paramname">l_fornextpath</td><td>list of new \( l \) at the new path iteration </td></tr>
    <tr><td class="paramname">best_path</td><td>save the best path </td></tr>
    <tr><td class="paramname">saves</td><td>the current iteration on the fly </td></tr>
    <tr><td class="paramname">MaximumGradient</td><td>maximum \( \nabla V \) </td></tr>
    <tr><td class="paramname">MaximumForce</td><td>maximum \( \vec{N} \) </td></tr>
    <tr><td class="paramname">MaximumRelativeError</td><td>maximum \( \frac{|\vec{N}|}{|\nabla V|} \) </td></tr>
    <tr><td class="paramname">Maximum_dldrho</td><td>maximum \( \frac{dl}{d\rho} \) </td></tr>
    <tr><td class="paramname">PerpendicularGradient</td><td>maximum \( \nabla_\perp V \) </td></tr>
    <tr><td class="paramname">inverseK</td><td>inverse of the kernel matrix </td></tr>
    <tr><td class="paramname">forces</td><td>list of forces to check if path is converging or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a885608a426afd615d80c13ef4a3c1172" name="a885608a426afd615d80c13ef4a3c1172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885608a426afd615d80c13ef4a3c1172">&#9670;&#160;</a></span>Solve1DBounce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BSMPT::BounceActionInt::Solve1DBounce </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dl_drho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>d2l_drho2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>error</em> = <code>1e-7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary search using the overshooting/undershooting method to find the solution to the 1D bounce equation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rho</td><td>is the vector of \( \rho \) values from the solution </td></tr>
    <tr><td class="paramname">l</td><td>is the vector of \( l \) values from the solution </td></tr>
    <tr><td class="paramname">dl_drho</td><td>is the vector of \( \frac{dl}{d\rho} \) values from the solution </td></tr>
    <tr><td class="paramname">d2l_drho2is</td><td>the vector of \( \frac{d^2l}{d\rho^2} \) values from the solution </td></tr>
    <tr><td class="paramname">error</td><td>is the <a class="el" href="classBSMPT_1_1BounceActionInt.html#ab6c0f5b4f40a029fc5a349e6032b1f6f">IntegrateBounce</a> error (acceptance of undershoot/overshoot) </td></tr>
    <tr><td class="paramname">maxiter</td><td>is the maximum number of binary searches </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae67bd826a910bac7a4d85518d7b1d509" name="ae67bd826a910bac7a4d85518d7b1d509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67bd826a910bac7a4d85518d7b1d509">&#9670;&#160;</a></span>Alpha</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BSMPT::BounceActionInt::Alpha = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factor produced by the spherical symmetry of the potential. </p>
<ul>
<li>= 2 if \( T &gt; 0\) ( \(O(3)\) symmetry).</li>
<li>= 3 if \( T = 0\) ( \(O(4)\) symmetry).</li>
</ul>
<p>Default value is \( 2 \) since most of our calculation are done at finite temperature. </p>

</div>
</div>
<a id="acb378b0fcb71d59f60ff85311273cd73" name="acb378b0fcb71d59f60ff85311273cd73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb378b0fcb71d59f60ff85311273cd73">&#9670;&#160;</a></span>Hessian</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;std::vector&lt;std::vector&lt;double&gt; &gt;(std::vector&lt;double&gt;)&gt; BSMPT::BounceActionInt::Hessian</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Potential hessian of the class, completly numerical. </p>
<p>TODO: Calculate hessian from analytical gradient </p>

</div>
</div>
<a id="a31b192a035855958fbbe882838598504" name="a31b192a035855958fbbe882838598504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b192a035855958fbbe882838598504">&#9670;&#160;</a></span>StateOfPathDeformation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBSMPT_1_1BounceActionInt.html#ac2647c816f414debde47db27d5b52326">PathDeformationStatus</a> BSMPT::BounceActionInt::StateOfPathDeformation</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      PathDeformationStatus::NotConverged</div>
</div><!-- fragment -->
<p>Status of the path deformation algorithm. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/BSMPT/bounce_solution/<a class="el" href="action__calculation_8h_source.html">action_calculation.h</a></li>
<li>src/bounce_solution/<a class="el" href="action__calculation_8cpp.html">action_calculation.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceBSMPT.html">BSMPT</a></li><li class="navelem"><a class="el" href="classBSMPT_1_1BounceActionInt.html">BounceActionInt</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
